def InceptionScore(img, batch_size=32, splits=1):
    N = len(img)
    data_loader = DataLoader(img, batch_size=batch_size)
    model = eval('models.classifier().to(config.PARAM["device"])')
    load_tag = 'best'
    model_tag = ['0', config.PARAM['data_name'], config.PARAM['subset'], 'classifier', '0']
    model_tag = '_'.join(filter(None, model_tag))
    last_epoch, model, _, _, _ = resume(model, model_tag, load_tag=load_tag, verbose=False)
    model.train(False)

    def get_pred(input):
        output = model(input)
        return F.softmax(output['label'], dim=-1).cpu().numpy()

    preds = np.zeros((N, config.PARAM['classes_size']))
    for i, input in enumerate(data_loader):
        input = {'img': input, 'label': input.new_zeros(input.size(0)).long()}
        input = to_device(input, config.PARAM['device'])
        input_size_i = input['img'].size(0)
        preds[i * batch_size:i * batch_size + input_size_i] = get_pred(input)
    split_scores = []
    for k in range(splits):
        part = preds[k * (N // splits): (k + 1) * (N // splits), :]
        py = np.mean(part, axis=0)
        scores = []
        for i in range(part.shape[0]):
            pyx = part[i, :]
            scores.append(entropy(pyx, py))
        split_scores.append(np.exp(np.mean(scores)))
    return np.mean(split_scores).item()